---
layout: post
title: "递归与状态设计总结"
date: 2026-02-18
---

# 递归的本质：从“规模缩小”到“决策树”


以前我对递归的理解比较简单：  
递归就是不断把问题规模缩小，直到遇到基础情况，然后再一层层返回。

但在做组合类问题时，我逐渐意识到：

> 递归的本质，其实是在构造一棵决策树。

当用“树”的视角重新看递归，很多问题突然变得清晰。

---

## 一、所有递归本质上都是树

递归函数的每一次调用，都会生成新的子问题。  
如果把每一次函数调用看作一个节点，就会形成一棵树。

- 根节点：原问题
- 子节点：拆分后的子问题
- 叶节点：满足 base case 的状态

从这个角度看，递归并不是“神秘的函数自我调用”，  
而是在隐式构建一棵状态树。

---

## 二、基础递归 vs 树形递归

### 1️⃣ 基础递归（线性递归）

当每一层只产生一个子问题时，递归树会退化成一条链。

特点：

- 每个节点只有一个子节点
- 没有分支
- 本质是“规模不断缩小”

这种递归结构简单，不容易产生重复子问题。

---

### 2️⃣ 树形递归

当每一层产生多个子问题时，就形成真正的树结构。

特点：

- 每个节点可能有多个子节点
- 代表不同决策
- 容易出现重复子树
- 可能需要记忆化优化

这类问题的关键不再只是“规模缩小”，  
而是“如何枚举所有可能的选择”。

---

## 三、递归的关键：状态设计

在理解树结构后，我意识到：

> 递归真正困难的地方，不是写函数，而是设计状态。

每一个节点必须包含：

- 当前所处的位置
- 决策历史中会影响未来的信息

如果状态不完整：

- 会出现重复
- 会出现路径混乱
- 会计算错误结果

如果状态冗余：

- 会导致分支爆炸
- 会产生更多重复子树

状态设计的目标是：

> 用最少的信息，完整描述未来。

---

## 四、重复子问题与记忆化

在树形递归中，经常会出现不同路径到达相同状态的情况。

例如：

- 不同选择顺序
- 不同分支合流
- 相同参数重复计算

这会导致大量重复子树。

解决方式是记忆化（memoization）：

- 把“状态”作为键
- 把计算结果缓存起来
- 再次遇到相同状态时直接返回结果

需要注意的是：

> 记忆化解决的是“重复状态”，而不是“错误状态”。

如果状态设计本身就混乱，记忆化只会缓存错误。

---

## 五、组合问题与排列问题的区别

当把递归看成决策树后，组合与排列的区别变得清晰。

### 1️⃣ 排列问题

特点：

- 顺序不同就是不同结果
- 每一步都会影响剩余选择
- 状态通常包含“已选元素”

排列问题本质是在遍历一棵完全展开的决策树。

---

### 2️⃣ 组合问题

特点：

- 不关心顺序
- 需要避免重复子树
- 通常通过“起始索引”限制分支

组合问题本质是在一棵受约束的决策树中遍历。

---

### 3️⃣ 核心区别总结

|            | 排列 | 组合 |
|------------|------|------|
| 是否考虑顺序 | 是 | 否 |
| 状态包含什么 | 已选元素 | 起始位置 |
| 是否容易重复 | 不会（天然区分） | 容易（需剪枝） |

---

## 总结

今天最大的收获：

- 所有递归本质上都是树
- 基础递归是分支数为 1 的特殊情况
- 树形递归的核心在于状态设计
- 记忆化只是优化手段
- 排列与组合的区别，本质是决策树是否需要约束

当开始用“树”的视角看问题，递归不再抽象，而是结构清晰的搜索过程。
